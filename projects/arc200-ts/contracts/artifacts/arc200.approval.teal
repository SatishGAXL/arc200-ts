#pragma version 10

// This TEAL was generated by TEALScript v0.98.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(string,string,uint8)void
*abi_route_createApplication:
	// decimals: uint8
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (decimals) for createApplication must be a uint8
	assert
	btoi

	// symbol: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createApplication(string,string,uint8)void
	callsub createApplication
	int 1
	return

// createApplication(name: bytes[32], symbol: bytes[8], decimals: uint8): void
//
// Contructor which initializes name, symbol, decimals and totalSupply of the token
//
// @param name
// @param symbol
// @param decimals
// @returns void
createApplication:
	proto 3 0

	// contracts\arc200.algo.ts:32
	// this.name.value = name
	byte 0x6e616d65 // "name"
	frame_dig -1 // name: bytes[32]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts\arc200.algo.ts:33
	// this.symbol.value = symbol
	byte 0x73796d626f6c // "symbol"
	frame_dig -2 // symbol: bytes[8]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts\arc200.algo.ts:34
	// this.decimals.value = decimals
	byte 0x646563696d616c73 // "decimals"
	frame_dig -3 // decimals: uint8
	itob
	extract 7 1
	app_global_put

	// contracts\arc200.algo.ts:35
	// this.totalSupply.value = 0 as uint256
	byte 0x746f74616c537570706c79 // "totalSupply"
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	app_global_put
	retsub

// arc200_name()string
*abi_route_arc200_name:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_name()string
	callsub arc200_name
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc200_name(): bytes[32]
//
// Returns the symbol of the token
//
// @returns symbol of the token
arc200_name:
	proto 0 1

	// contracts\arc200.algo.ts:44
	// return this.name.value;
	byte 0x6e616d65 // "name"
	app_global_get
	extract 2 0
	retsub

// arc200_symbol()string
*abi_route_arc200_symbol:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_symbol()string
	callsub arc200_symbol
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc200_symbol(): bytes[8]
//
// Returns the decimals of the token
//
// @returns decimals of the token
arc200_symbol:
	proto 0 1

	// contracts\arc200.algo.ts:53
	// return this.symbol.value;
	byte 0x73796d626f6c // "symbol"
	app_global_get
	extract 2 0
	retsub

// arc200_decimals()uint8
*abi_route_arc200_decimals:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_decimals()uint8
	callsub arc200_decimals
	itob
	dup
	bitlen
	int 8
	<=

	// arc200_decimals return value overflowed 8 bits
	assert
	extract 7 1
	concat
	log
	int 1
	return

// arc200_decimals(): uint8
//
// Returns the decimals of the token
//
// @returns decimals of the token
arc200_decimals:
	proto 0 1

	// contracts\arc200.algo.ts:62
	// return this.decimals.value;
	byte 0x646563696d616c73 // "decimals"
	app_global_get
	btoi
	retsub

// arc200_totalSupply()uint256
*abi_route_arc200_totalSupply:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc200_totalSupply()uint256
	callsub arc200_totalSupply
	dup
	bitlen
	int 256
	<=

	// arc200_totalSupply return value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_totalSupply(): uint256
//
// Returns the total supply of the token
//
// @returns total supply of the token
arc200_totalSupply:
	proto 0 1

	// contracts\arc200.algo.ts:71
	// return this.totalSupply.value;
	byte 0x746f74616c537570706c79 // "totalSupply"
	app_global_get
	retsub

// arc200_balanceOf(address)uint256
*abi_route_arc200_balanceOf:
	// The ABI return prefix
	byte 0x151f7c75

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (owner) for arc200_balanceOf must be a address
	assert

	// execute arc200_balanceOf(address)uint256
	callsub arc200_balanceOf
	dup
	bitlen
	int 256
	<=

	// arc200_balanceOf return value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_balanceOf(owner: Address): uint256
//
// Returns the current balance of the owner of the token
//
// @param owner
// @returns current balance of the owner of the token
arc200_balanceOf:
	proto 1 1

	// *if0_condition
	// contracts\arc200.algo.ts:81
	// this.users(owner).exists
	frame_dig -1 // owner: Address
	box_len
	swap
	pop
	bz *if0_else

	// *if0_consequent
	// contracts\arc200.algo.ts:82
	// return this.users(owner).value.balance;
	frame_dig -1 // owner: Address
	box_get

	// box value does not exist: this.users(owner).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	retsub
	b *if0_end

*if0_else:
	// contracts\arc200.algo.ts:84
	// return 0 as uint256;
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	retsub

*if0_end:
	retsub

// arc200_transfer(address,uint256)bool
*abi_route_arc200_transfer:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (value) for arc200_transfer must be a uint256
	assert

	// to: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (to) for arc200_transfer must be a address
	assert

	// execute arc200_transfer(address,uint256)bool
	callsub arc200_transfer
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_transfer(to: Address, value: uint256): boolean
//
// Transfers tokens
//
// @param to - The destination of the transfer
// @param value - Amount of tokens to transfer
// @returns Status whether transfer is success or not
arc200_transfer:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\arc200.algo.ts:96
	// sender = this.txn.sender
	txn Sender
	frame_bury 0 // sender: address

	// contracts\arc200.algo.ts:97
	// assert(this.userExists(sender), 'No Balance Available in Sender Account')
	frame_dig 0 // sender: address
	callsub userExists

	// No Balance Available in Sender Account
	assert

	// contracts\arc200.algo.ts:98
	// assert(this.ensureBalance(sender, value), 'Insufficient Balance in Sender Account')
	frame_dig -2 // value: uint256
	frame_dig 0 // sender: address
	callsub ensureBalance

	// Insufficient Balance in Sender Account
	assert

	// contracts\arc200.algo.ts:99
	// assert(to != globals.zeroAddress, 'Sending to Zero Address is not Allowed')
	frame_dig -1 // to: Address
	global ZeroAddress
	!=

	// Sending to Zero Address is not Allowed
	assert

	// contracts\arc200.algo.ts:100
	// this._transfer(sender, to, value)
	frame_dig -2 // value: uint256
	frame_dig -1 // to: Address
	frame_dig 0 // sender: address
	callsub _transfer

	// contracts\arc200.algo.ts:101
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0
	retsub

// arc200_transferFrom(address,address,uint256)bool
*abi_route_arc200_transferFrom:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (value) for arc200_transferFrom must be a uint256
	assert

	// to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (to) for arc200_transferFrom must be a address
	assert

	// from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (from) for arc200_transferFrom must be a address
	assert

	// execute arc200_transferFrom(address,address,uint256)bool
	callsub arc200_transferFrom
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_transferFrom(from: Address, to: Address, value: uint256): boolean
//
// Transfers tokens from source to destination as approved spenderTransfers tokens from source to destination as approved spender
//
// @param from - The source  of the transfer
// @param to - The destination of the transfer
// @param value - Amount of tokens to transfer
// @returns Status whether transfer is success or not
arc200_transferFrom:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\arc200.algo.ts:113
	// spender = this.txn.sender
	txn Sender
	frame_bury 0 // spender: address

	// contracts\arc200.algo.ts:114
	// assert(this.userExists(from), 'No Balance Available in Sender Account')
	frame_dig -1 // from: Address
	callsub userExists

	// No Balance Available in Sender Account
	assert

	// contracts\arc200.algo.ts:115
	// assert(this.ensureBalance(from, value), 'Insufficient Balance in Sender Account')
	frame_dig -3 // value: uint256
	frame_dig -1 // from: Address
	callsub ensureBalance

	// Insufficient Balance in Sender Account
	assert

	// contracts\arc200.algo.ts:116
	// assert(to != globals.zeroAddress, 'Sending to Zero Address is not Allowed')
	frame_dig -2 // to: Address
	global ZeroAddress
	!=

	// Sending to Zero Address is not Allowed
	assert

	// contracts\arc200.algo.ts:117
	// check = this.checkAllowanceAvailable(from, spender)
	frame_dig 0 // spender: address
	frame_dig -1 // from: Address
	callsub checkAllowanceAvailable
	frame_bury 1 // check: (bool,uint64)

	// contracts\arc200.algo.ts:118
	// assert(check[0], 'Allowance Not Available')
	frame_dig 1 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	int 0
	getbit

	// Allowance Not Available
	assert

	// contracts\arc200.algo.ts:119
	// allowance = this.getAllowance(from, check[1])
	frame_dig 1 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig -1 // from: Address
	callsub getAllowance
	frame_bury 2 // allowance: (address,uint256)

	// contracts\arc200.algo.ts:120
	// assert(allowance.amount >= value, 'Amount is less than balance in Allowance')
	frame_dig 2 // allowance: (address,uint256)
	extract 32 32
	frame_dig -3 // value: uint256
	b>=

	// Amount is less than balance in Allowance
	assert

	// contracts\arc200.algo.ts:121
	// this._transfer(from, to, value)
	frame_dig -3 // value: uint256
	frame_dig -2 // to: Address
	frame_dig -1 // from: Address
	callsub _transfer

	// contracts\arc200.algo.ts:122
	// this.updateAllowance(from, allowance.amount - value, check[1])
	frame_dig 1 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig 2 // allowance: (address,uint256)
	extract 32 32
	frame_dig -3 // value: uint256
	b-
	dup
	bitlen
	int 256
	<=

	// allowance.amount - value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	frame_dig -1 // from: Address
	callsub updateAllowance

	// contracts\arc200.algo.ts:123
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// arc200_approve(address,uint256)bool
*abi_route_arc200_approve:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (value) for arc200_approve must be a uint256
	assert

	// spender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (spender) for arc200_approve must be a address
	assert

	// execute arc200_approve(address,uint256)bool
	callsub arc200_approve
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_approve(spender: Address, value: uint256): boolean
arc200_approve:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\arc200.algo.ts:127
	// assert(spender != globals.zeroAddress, 'Cannot Give ALlowance to Zero Address')
	frame_dig -1 // spender: Address
	global ZeroAddress
	!=

	// Cannot Give ALlowance to Zero Address
	assert

	// contracts\arc200.algo.ts:128
	// check = this.checkAllowanceAvailable(this.txn.sender, spender)
	frame_dig -1 // spender: Address
	txn Sender
	callsub checkAllowanceAvailable
	frame_bury 0 // check: (bool,uint64)

	// *if1_condition
	// contracts\arc200.algo.ts:129
	// check[0]
	frame_dig 0 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	bz *if1_else

	// *if1_consequent
	// contracts\arc200.algo.ts:130
	// this.updateAllowance(this.txn.sender, value, check[1])
	frame_dig 0 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig -2 // value: uint256
	txn Sender
	callsub updateAllowance
	b *if1_end

*if1_else:
	// contracts\arc200.algo.ts:132
	// this.addAllowance(this.txn.sender, spender, value)
	frame_dig -2 // value: uint256
	frame_dig -1 // spender: Address
	txn Sender
	callsub addAllowance

*if1_end:
	// contracts\arc200.algo.ts:134
	// this.arc200_Approval.log({ owner: this.txn.sender, spender: spender, value: value })
	byte 0x1969f865 // arc200_Approval(address,address,uint256)
	txn Sender
	frame_dig -1 // spender: Address
	concat
	frame_dig -2 // value: uint256
	concat
	concat
	log

	// contracts\arc200.algo.ts:135
	// return true;
	int 1

	// set the subroutine return value
	frame_bury 0
	retsub

// arc200_allowance(address,address)uint256
*abi_route_arc200_allowance:
	// The ABI return prefix
	byte 0x151f7c75

	// spender: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (spender) for arc200_allowance must be a address
	assert

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (owner) for arc200_allowance must be a address
	assert

	// execute arc200_allowance(address,address)uint256
	callsub arc200_allowance
	dup
	bitlen
	int 256
	<=

	// arc200_allowance return value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	log
	int 1
	return

// arc200_allowance(owner: Address, spender: Address): uint256
arc200_allowance:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\arc200.algo.ts:139
	// check = this.checkAllowanceAvailable(this.txn.sender, spender)
	frame_dig -2 // spender: Address
	txn Sender
	callsub checkAllowanceAvailable
	frame_bury 0 // check: (bool,uint64)

	// contracts\arc200.algo.ts:140
	// assert(check[0], 'Allowance Not Available')
	frame_dig 0 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	int 0
	getbit

	// Allowance Not Available
	assert

	// contracts\arc200.algo.ts:142
	// allowance = this.getAllowance(owner, check[1])
	frame_dig 0 // check: (bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig -1 // owner: Address
	callsub getAllowance
	frame_bury 1 // allowance: (address,uint256)

	// contracts\arc200.algo.ts:143
	// return allowance.amount;
	frame_dig 1 // allowance: (address,uint256)
	extract 32 32

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// arc200_mint(address,uint256)bool
*abi_route_arc200_mint:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (value) for arc200_mint must be a uint256
	assert

	// account: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (account) for arc200_mint must be a address
	assert

	// execute arc200_mint(address,uint256)bool
	callsub arc200_mint
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_mint(account: Address, value: uint256): boolean
arc200_mint:
	proto 2 1

	// *if2_condition
	// contracts\arc200.algo.ts:147
	// !this.users(globals.zeroAddress).exists
	global ZeroAddress
	box_len
	swap
	pop
	!
	bz *if2_end

	// *if2_consequent
	// contracts\arc200.algo.ts:148
	// this.users(globals.zeroAddress).value = { balance: 0 as uint256, allowances: [] }
	global ZeroAddress
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	callsub *process_static_tuple_element
	byte 0x0000
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

*if2_end:
	// contracts\arc200.algo.ts:150
	// assert(this.txn.sender == this.app.creator, 'Only Admin Can Mint')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only Admin Can Mint
	assert

	// contracts\arc200.algo.ts:151
	// assert(account != globals.zeroAddress, 'Cannot Mint to Zero Address')
	frame_dig -1 // account: Address
	global ZeroAddress
	!=

	// Cannot Mint to Zero Address
	assert

	// contracts\arc200.algo.ts:152
	// this._transfer(globals.zeroAddress, account, value)
	frame_dig -2 // value: uint256
	frame_dig -1 // account: Address
	global ZeroAddress
	callsub _transfer

	// contracts\arc200.algo.ts:153
	// return true;
	int 1
	retsub

// arc200_burn(address,uint256)bool
*abi_route_arc200_burn:
	// The ABI return prefix
	byte 0x151f7c75

	// value: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (value) for arc200_burn must be a uint256
	assert

	// account: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (account) for arc200_burn must be a address
	assert

	// execute arc200_burn(address,uint256)bool
	callsub arc200_burn
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc200_burn(account: Address, value: uint256): boolean
arc200_burn:
	proto 2 1

	// contracts\arc200.algo.ts:157
	// assert(this.txn.sender == this.app.creator, 'Only Admin Can Burn')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only Admin Can Burn
	assert

	// contracts\arc200.algo.ts:158
	// assert(account != globals.zeroAddress, 'Cannot Burn from Zero Address')
	frame_dig -1 // account: Address
	global ZeroAddress
	!=

	// Cannot Burn from Zero Address
	assert

	// contracts\arc200.algo.ts:159
	// assert(this.userExists(account), 'No Balance Available To Burn From Account')
	frame_dig -1 // account: Address
	callsub userExists

	// No Balance Available To Burn From Account
	assert

	// contracts\arc200.algo.ts:160
	// assert(this.ensureBalance(account, value), 'Insufficient Balance To Burn From Account')
	frame_dig -2 // value: uint256
	frame_dig -1 // account: Address
	callsub ensureBalance

	// Insufficient Balance To Burn From Account
	assert

	// contracts\arc200.algo.ts:161
	// this._transfer(account, globals.zeroAddress, value)
	frame_dig -2 // value: uint256
	global ZeroAddress
	frame_dig -1 // account: Address
	callsub _transfer

	// contracts\arc200.algo.ts:162
	// return true;
	int 1
	retsub

// userExists(user: Address): boolean
userExists:
	proto 1 1

	// contracts\arc200.algo.ts:166
	// return this.users(user).exists;
	frame_dig -1 // user: Address
	box_len
	swap
	pop
	retsub

// ensureBalance(user: Address, balance: uint256): boolean
ensureBalance:
	proto 2 1

	// contracts\arc200.algo.ts:170
	// return this.users(user).value.balance >= balance;
	frame_dig -1 // user: Address
	box_get

	// box value does not exist: this.users(user).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -2 // balance: uint256
	b>=
	retsub

// createNewUser(user: Address, balance: uint256): void
createNewUser:
	proto 2 0

	// contracts\arc200.algo.ts:174
	// this.users(user).value = { balance: balance, allowances: [] }
	frame_dig -1 // user: Address
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -2 // balance: uint256
	callsub *process_static_tuple_element
	byte 0x0000
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put
	retsub

// _transfer(from: Address, to: Address, value: uint256): void
_transfer:
	proto 3 0

	// contracts\arc200.algo.ts:178
	// assert(!(from == globals.zeroAddress && to == globals.zeroAddress), 'Both Address Should not be zero')
	frame_dig -1 // from: Address
	global ZeroAddress
	==
	dup
	bz *skip_and0
	frame_dig -2 // to: Address
	global ZeroAddress
	==
	&&

*skip_and0:
	!

	// Both Address Should not be zero
	assert

	// *if3_condition
	// contracts\arc200.algo.ts:179
	// from == globals.zeroAddress
	frame_dig -1 // from: Address
	global ZeroAddress
	==
	bz *if3_elseif1_condition

	// *if3_consequent
	// *if4_condition
	// contracts\arc200.algo.ts:180
	// this.users(to).exists
	frame_dig -2 // to: Address
	box_len
	swap
	pop
	bz *if4_else

	// *if4_consequent
	// contracts\arc200.algo.ts:181
	// this.users(to).value.balance = this.users(to).value.balance + value
	frame_dig -2 // to: Address
	box_get

	// box value does not exist: this.users(to).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -2 // to: Address
	box_get

	// box value does not exist: this.users(to).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -3 // value: uint256
	b+
	dup
	bitlen
	int 256
	<=

	// this.users(to).value.balance + value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	replace3
	frame_dig -2 // to: Address
	dup
	box_del
	pop
	swap
	box_put
	b *if4_end

*if4_else:
	// contracts\arc200.algo.ts:183
	// this.createNewUser(to, value)
	frame_dig -3 // value: uint256
	frame_dig -2 // to: Address
	callsub createNewUser

*if4_end:
	// contracts\arc200.algo.ts:185
	// this.totalSupply.value = this.totalSupply.value + value
	byte 0x746f74616c537570706c79 // "totalSupply"
	dup
	app_global_get
	frame_dig -3 // value: uint256
	b+
	dup
	bitlen
	int 256
	<=

	// this.totalSupply.value + value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put
	b *if3_end

*if3_elseif1_condition:
	// contracts\arc200.algo.ts:186
	// to == globals.zeroAddress
	frame_dig -2 // to: Address
	global ZeroAddress
	==
	bz *if3_else

	// *if3_elseif1_consequent
	// contracts\arc200.algo.ts:187
	// this.users(globals.zeroAddress).value.balance = this.users(globals.zeroAddress).value.balance + value
	global ZeroAddress
	box_get

	// box value does not exist: this.users(globals.zeroAddress).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	global ZeroAddress
	box_get

	// box value does not exist: this.users(globals.zeroAddress).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -3 // value: uint256
	b+
	dup
	bitlen
	int 256
	<=

	// this.users(globals.zeroAddress).value.balance + value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	replace3
	global ZeroAddress
	dup
	box_del
	pop
	swap
	box_put

	// contracts\arc200.algo.ts:188
	// this.users(from).value.balance = this.users(from).value.balance - value
	frame_dig -1 // from: Address
	box_get

	// box value does not exist: this.users(from).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -1 // from: Address
	box_get

	// box value does not exist: this.users(from).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -3 // value: uint256
	b-
	dup
	bitlen
	int 256
	<=

	// this.users(from).value.balance - value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	replace3
	frame_dig -1 // from: Address
	dup
	box_del
	pop
	swap
	box_put

	// contracts\arc200.algo.ts:189
	// this.totalSupply.value = this.totalSupply.value - value
	byte 0x746f74616c537570706c79 // "totalSupply"
	dup
	app_global_get
	frame_dig -3 // value: uint256
	b-
	dup
	bitlen
	int 256
	<=

	// this.totalSupply.value - value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	app_global_put
	b *if3_end

*if3_else:
	// *if5_condition
	// contracts\arc200.algo.ts:191
	// this.users(to).exists
	frame_dig -2 // to: Address
	box_len
	swap
	pop
	bz *if5_else

	// *if5_consequent
	// contracts\arc200.algo.ts:192
	// this.users(to).value.balance = this.users(to).value.balance + value
	frame_dig -2 // to: Address
	box_get

	// box value does not exist: this.users(to).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -2 // to: Address
	box_get

	// box value does not exist: this.users(to).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -3 // value: uint256
	b+
	dup
	bitlen
	int 256
	<=

	// this.users(to).value.balance + value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	replace3
	frame_dig -2 // to: Address
	dup
	box_del
	pop
	swap
	box_put
	b *if5_end

*if5_else:
	// contracts\arc200.algo.ts:194
	// this.createNewUser(to, value)
	frame_dig -3 // value: uint256
	frame_dig -2 // to: Address
	callsub createNewUser

*if5_end:
	// contracts\arc200.algo.ts:196
	// this.users(from).value.balance = this.users(from).value.balance - value
	frame_dig -1 // from: Address
	box_get

	// box value does not exist: this.users(from).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -1 // from: Address
	box_get

	// box value does not exist: this.users(from).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -3 // value: uint256
	b-
	dup
	bitlen
	int 256
	<=

	// this.users(from).value.balance - value overflowed 256 bits
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	replace3
	frame_dig -1 // from: Address
	dup
	box_del
	pop
	swap
	box_put

*if3_end:
	// contracts\arc200.algo.ts:199
	// this.arc200_Transfer.log({ from: from, to: to, value: value })
	byte 0x7983c35c // arc200_Transfer(address,address,uint256)
	frame_dig -1 // from: Address
	frame_dig -2 // to: Address
	concat
	frame_dig -3 // value: uint256
	concat
	concat
	log
	retsub

// checkAllowanceAvailable(user: Address, spender: Address): [boolean, uint64]
checkAllowanceAvailable:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts\arc200.algo.ts:203
	// allowances = this.users(user).value.allowances
	frame_dig -1 // user: Address
	frame_bury 0 // storage key//allowances

	// contracts\arc200.algo.ts:204
	// allowancesLength = (this.users(user).size - 36) / 64
	frame_dig -1 // user: Address
	box_len

	// box value does not exist: this.users(user).size
	assert
	int 36
	-
	int 64
	/
	frame_bury 1 // allowancesLength: uint64

	// contracts\arc200.algo.ts:205
	// allowanceFound = false
	int 0
	frame_bury 2 // allowanceFound: bool

	// contracts\arc200.algo.ts:206
	// allowanceIndex = 0
	int 0
	frame_bury 3 // allowanceIndex: uint64

	// contracts\arc200.algo.ts:208
	// for (let index = 0; index < allowancesLength; index += 1)
	int 0
	frame_bury 4 // index: uint64

*for_0:
	// contracts\arc200.algo.ts:208
	// index < allowancesLength
	frame_dig 4 // index: uint64
	frame_dig 1 // allowancesLength: uint64
	<
	bz *for_0_end

	// *if6_condition
	// contracts\arc200.algo.ts:209
	// allowances[index].spender == spender
	frame_dig 0 // storage key//allowances
	box_get

	// box value does not exist: this.users(user).value
	assert
	store 255 // full array
	load 255 // full array
	int 32
	extract_uint16
	frame_dig 4 // index: uint64
	int 64
	* // acc * typeLength
	+
	int 2
	+ // add two for length
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_dig -2 // spender: Address
	==
	bz *if6_end

	// *if6_consequent
	// contracts\arc200.algo.ts:210
	// allowanceFound = true
	int 1
	frame_bury 2 // allowanceFound: bool

	// contracts\arc200.algo.ts:211
	// allowanceIndex = index
	frame_dig 4 // index: uint64
	frame_bury 3 // allowanceIndex: uint64
	b *for_0_end

*if6_end:

*for_0_continue:
	// contracts\arc200.algo.ts:208
	// index += 1
	frame_dig 4 // index: uint64
	int 1
	+
	frame_bury 4 // index: uint64
	b *for_0

*for_0_end:
	// contracts\arc200.algo.ts:216
	// return [allowanceFound, allowanceIndex];
	byte 0x00
	int 0
	frame_dig 2 // allowanceFound: bool
	setbit
	frame_dig 3 // allowanceIndex: uint64
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// updateAllowance(user: Address, balance: uint256, index: uint64): void
updateAllowance:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\arc200.algo.ts:220
	// allowances = this.users(user).value.allowances
	frame_dig -1 // user: Address
	frame_bury 0 // storage key//allowances

	// contracts\arc200.algo.ts:221
	// allowances[index].amount = balance
	frame_dig 0 // storage key//allowances
	box_get

	// box value does not exist: this.users(user).value
	assert
	store 255 // full array
	load 255 // full array
	int 32
	extract_uint16
	frame_dig -3 // index: uint64
	int 64
	* // acc * typeLength
	+
	int 2
	+ // add two for length
	int 32 // headOffset
	+
	load 255 // full array
	swap
	frame_dig -2 // balance: uint256
	replace3
	frame_dig 0 // storage key//allowances
	dup
	box_del
	pop
	swap
	box_put
	retsub

// addAllowance(user: Address, spender: Address, balance: uint256): void
addAllowance:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts\arc200.algo.ts:225
	// allowances = this.users(user).value.allowances
	frame_dig -1 // user: Address
	frame_bury 0 // storage key//allowances

	// contracts\arc200.algo.ts:226
	// newAllowance: Allowance[] = []
	byte 0x
	frame_bury 1 // newAllowance: Allowance[]

	// contracts\arc200.algo.ts:227
	// allowancesLength = (this.users(user).size - 36) / 64
	frame_dig -1 // user: Address
	box_len

	// box value does not exist: this.users(user).size
	assert
	int 36
	-
	int 64
	/
	frame_bury 2 // allowancesLength: uint64

	// contracts\arc200.algo.ts:228
	// newElement: Allowance = { spender: spender, amount: balance }
	frame_dig -2 // spender: Address
	frame_dig -3 // balance: uint256
	concat
	frame_bury 3 // newElement: Allowance

	// contracts\arc200.algo.ts:230
	// for (let i = 0; i < allowancesLength; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_1:
	// contracts\arc200.algo.ts:230
	// i < allowancesLength
	frame_dig 4 // i: uint64
	frame_dig 2 // allowancesLength: uint64
	<
	bz *for_1_end

	// contracts\arc200.algo.ts:231
	// newAllowance.push(allowances[i])
	frame_dig 1 // newAllowance: Allowance[]
	frame_dig 0 // storage key//allowances
	box_get

	// box value does not exist: this.users(user).value
	assert
	store 255 // full array
	load 255 // full array
	int 32
	extract_uint16
	frame_dig 4 // i: uint64
	int 64
	* // acc * typeLength
	+
	int 2
	+ // add two for length
	load 255 // full array
	swap
	int 64
	extract3
	concat
	frame_bury 1 // newAllowance: Allowance[]

*for_1_continue:
	// contracts\arc200.algo.ts:230
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_1

*for_1_end:
	// contracts\arc200.algo.ts:234
	// newAllowance.push(newElement)
	frame_dig 1 // newAllowance: Allowance[]
	frame_dig 3 // newElement: Allowance
	concat
	frame_bury 1 // newAllowance: Allowance[]

	// contracts\arc200.algo.ts:235
	// this.users(user).value.allowances = newAllowance
	frame_dig -1 // user: Address
	box_get

	// box value does not exist: this.users(user).value
	assert
	store 255 // full array
	int 32
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 64 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	int 0
	load 254 // element start
	substring3
	frame_dig 1 // newAllowance: Allowance[]
	dup
	len
	int 64
	/
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 255 // full array
	frame_dig -1 // user: Address
	dup
	box_del
	pop
	swap
	box_put
	retsub

// getAllowance(user: Address, index: uint64): Allowance
getAllowance:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\arc200.algo.ts:239
	// addressOffset = index * 64 + 36
	frame_dig -2 // index: uint64
	int 64
	*
	int 36
	+
	frame_bury 0 // addressOffset: uint64

	// contracts\arc200.algo.ts:240
	// valueOffset = addressOffset + 32
	frame_dig 0 // addressOffset: uint64
	int 32
	+
	frame_bury 1 // valueOffset: uint64

	// contracts\arc200.algo.ts:241
	// return {
	//       spender: castBytes<Address>(this.users(user).extract(addressOffset, 32)),
	//       amount: castBytes<uint256>(this.users(user).extract(valueOffset, 32)),
	//     };
	frame_dig -1 // user: Address
	frame_dig 0 // addressOffset: uint64
	int 32
	box_extract
	frame_dig -1 // user: Address
	frame_dig 1 // valueOffset: uint64
	int 32
	box_extract
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

*create_NoOp:
	method "createApplication(string,string,uint8)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "arc200_name()string"
	method "arc200_symbol()string"
	method "arc200_decimals()uint8"
	method "arc200_totalSupply()uint256"
	method "arc200_balanceOf(address)uint256"
	method "arc200_transfer(address,uint256)bool"
	method "arc200_transferFrom(address,address,uint256)bool"
	method "arc200_approve(address,uint256)bool"
	method "arc200_allowance(address,address)uint256"
	method "arc200_mint(address,uint256)bool"
	method "arc200_burn(address,uint256)bool"
	txna ApplicationArgs 0
	match *abi_route_arc200_name *abi_route_arc200_symbol *abi_route_arc200_decimals *abi_route_arc200_totalSupply *abi_route_arc200_balanceOf *abi_route_arc200_transfer *abi_route_arc200_transferFrom *abi_route_arc200_approve *abi_route_arc200_allowance *abi_route_arc200_mint *abi_route_arc200_burn

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*get_length_difference:
	load 252 // new element
	len // length of new element
	load 253 // element length
	<
	bnz *swapped_difference
	load 252 // new element
	len // length of new element
	load 253 // element length
	int 1
	store 249 // subtract head difference
	b *get_difference

*swapped_difference:
	load 253 // element length
	load 252 // new element
	len // length of new element
	int 0
	store 249 // subtract head difference

*get_difference:
	- // get length difference
	store 250 // length difference
	retsub